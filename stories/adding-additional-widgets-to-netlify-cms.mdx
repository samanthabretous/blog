---
templateKey: blog-post
title: Adding Additional Widgets to Netlify CMS
date: 2019-09-01T10:34:22.668Z
featuredImage: /img/adding-additional-widgets/adding-additional-widgets-to-netlify-cms-thumb.png
thumbnail: /img/adding-additional-widgets/adding-additional-widgets-to-netlify-cms-thumb.png
isFeaturedPost: false
draft: true
description: How to add a custom widget to netlify cms
tags:
  - tutorial
  - d3
---

Recently I created a blog using [Gatsby](https://www.gatsbyjs.org/) and [Netlify CMS](https://www.netlifycms.org/). Combining the two services was quiet easy, especially, if you start off using the [gatsby-netlify-cms-starter](https://github.com/netlify-templates/gatsby-starter-netlify-cms) template. Do you see the feature image above? The one with the wooden figures? Go head take a look -- that didn't come right out of the box. In Netlify CMS terms this image is called a [widget](https://www.netlifycms.org/docs/widgets/) and I'm going to show you how to add one. But before we can begin we have to understand the differences between the two services. 

### [So what is Gatsby](#what-is-gatsby)
If you know React the learning curve to understand Gatsby is not that far off -- but there is still learning to do. There are other static site generators like [Jekyll](https://jekyllrb.com/) and [Hugo](https://gohugo.io/). But I choose Gatsby because I have a strong understanding of React, wanted to still be updated with GraphQL and received a Progressive Web App(PWA), and data splitting off the bat. Gatsby uses GraphQL to create a data layer with Markdown, JSON, third party API's or pretty much where data is available. _So what does that mean?_ Traditionally with web development we send over an a html file to the client. Then the html file sends out a request to fetch the data needed to render the content. This is called a HTTP Request and Response. Where as with static site generators, The server fetches the data and renders the content in a template. Then it send one completed html file to the client. This allows for faster websites and more security. 

<div style={{display: 'flex', flexDirection: 'row'}}>
  <img style={{width: '50%'}} src="/img/adding-additional-widgets/traditional-data-fetching-flow.png" alt="Diagram of Traditional Web fetching" />
  <img style={{width: '50%'}} src="/img/adding-additional-widgets/static-site-generator-flow.png" alt="Diagram of Static site generators" />
</div>


### [Netlify CMS who dis?](#what-is-netlify-cms)
Netlify and Netlify CMS are from the same family but are two separate entities. Netlify allows for version-controlled site deploys. Github Pages also allows for this but I would consider Netlify as the grown-up version. This is because with Netlify there are quick rollbacks to previous deploys, form handling, and my favorite branch deploys with previews. All of these features are out of scope for Github Pages and you can find all the limitations Netlify avoids [here](https://www.netlify.com/github-pages-vs-netlify/). 

I think of Netlify as the infrastructure for Netlify CMS where as the CMS supports all the content for your website. The CMS also provides an online editor for non developers can add and management blog posts, pages, products, or any custom content types. If you are thinking why use Netlify CMS over WordPress. Well you no longer need to pay for database to keep your content. Your remote git repository will store it for you in markdown.

### How to add a widget
Now that we understand the benefits that each service provides let figure out how to add a widget to our site. For the most part there isn't a clear divide between the two service in the gatsby-netlify-cms-starter template. Both Gatsby and Netlify CMS both share a large amount of the same files. But I was able to break it down to which files we can focus on. 

**These are the files that are important to Gatsby**
- [gatsby-config.js](https://github.com/netlify-templates/gatsby-starter-netlify-cms/blob/master/gatsby-config.js) - This is the heart of Gatsby. Since Gatsby is built with JavaScript, this means we need to use a lot of node modules to make it run. In return we need to tell Gatsby how to use these node packages. Each package usually includes a set of configuration options to narrow it down to your needs.
- [gatsby-node.js](https://github.com/netlify-templates/gatsby-starter-netlify-cms/blob/master/gatsby-node.js) - This is the file that kicks off the build. In the starter template kit, the build will trigger `onCreateNode`. Within this function Gatsby will begin to grab all the plugin files. This will consist of mostly Gatsby internal files and other plugins from your gatsby config file. At this point we don't care about those file. Gatsby will then move on to grabbing all you files in `static/img`. We takes those files and pass them to `fmImagesToRelative` to convert paths so they can be used by gatsby images. And lastly Gatsby will grab all your content files in the `pages` directory. In our case it will be all the markdown files. Next Gatsby will kickoff `onCreatePages`. Within this function gatsby makes a graphql call to get all the markdown files and converts each one into an page object. And then run through all the tags defined in the markdown files and creates pages from those. Last step of this function that happens in the background is grabbing all the .js with in the pages directory and creating pages. 

_Pretty fancy stuff!!!_

Since this file is in the build process, if you are curious to understand what this file does in more detail, you will need to run a debugger in order to debug.
```shell
// running the debugger in VS Code
$ npm run clean
$ node --nolazy --inspect-brk node_modules/.bin/gatsby develop
```

**These are the files that are important to Netlify CMS**
- [src/cms/**](https://github.com/netlify-templates/gatsby-starter-netlify-cms/tree/master/src/cms) - The Netlify CMS admin editor doesn't understand anything about GraphQL. GraphQL belongs to Gatsby so it reads all the information from the editor itself. When our React files needs data we look for our data through the widgets.
- [static/admin/config.yml](https://github.com/netlify-templates/gatsby-starter-netlify-cms/blob/master/static/admin/config.yml) - This houses [collections](https://www.netlifycms.org/docs/collection-types/) which can either be a folder of file collection. These are the field you see in the CMS editor online.

#### Prerequisites:
Clone [gatsby-netlify-cms-starter](https://github.com/netlify-templates/gatsby-starter-netlify-cms) template and follow the steps in the readme. 

#### Step 1 - Field Type: 
To begin, a field type needs to be added to the blog post collection. We can find this collection in `static/admin/config.yml`. 

```yaml
- {label: "Featured Image", name: "featuredImage", widget: "image", required: true}
```
- label: text that shows up in the admin editor
- name: field name that get generated in the markdown frontmatter
- widget: type of widget ie: boolean, date etc
- required: default is false 

After doing so, run `npm start`. Open [localhost:8000/admin](http://localhost:8000/admin) to view the CMS and select a blog post entry. A `Featured Image` field should appear in the editor. Once you confirm that this new field type is available, commit the changes and push it to the online repository that is connected to Netlify. 

#### Step 2 - Creating New Frontmatter Item:
Now add an image to the Featured Image field, and publish the blog post. When publishing, the CMS creates a commit message and pushes it to the master branch of your online repository. Netlify will pick up the change and deploy your site.

Since master has been updated, let's keep everything in sync and pull down from master in your terminal. Navigate to the markdown file that is related to the blog post we just edited in the CMS. It will live in `src/pages/blog`. We will now see a new frontmatter field in the markdown with a path to updated image. 

#### Step 3 - Reading From CMS Editor:
Simply put, Netlify CMS doesn't understand GraphQL. Even though the CMS blog preview and our actually sites uses the same file `src/templates/blog-post`, they get their data from two different sources. The preview section of the CMS editor uses the content within the editor, for its data. In order for this to happen, we need to register the data with `CMS.registerPreviewTemplate`. It is already done for us in `src/cms/cms.js`. So when the blog post template calls `<BlogPostTemplate />`, the file replaces the one inside for the CMS equivalent. We can tell CMS editor how to find how to find our new image by updating the component in `src/cms/preview-templates/BlogPostPreview`.

```javascript
featuredImage={entry.getIn(["data", "featuredImage"])}
```

_That is it for all for Netlify CMS tasks. We are all set up to figure out how Gatsby will use this new featured image field type._

#### Step 4
Lets set up the feature image on our site. Will need to use the package `gatsby-image`, so we can get optimized images. It should already be install. We can confirm the package has been installed by checking our `package.json` file.

Now it is as simple as one, two, three. We just need to update our GraphQL query to look for the image in our frontmatter field. Add this in `src/templates/blog-post.js`

```graphql
featuredImage {
  childImageSharp {
    fluid(maxWidth: 630) {
      ...GatsbyImageSharpFluid_noBase64
    }
  }
}
```

**That's it!!! We have a image that works both in the CMS editor and on our site. Good Job**

A couple things to note: When querying for this new image, all existing markdown files will also need a `featuredImage` frontmatter field. Good news is we don't have to do Steps 1 and 2 again. We can add a frontmatter field to each markdown file. We can place all our images in `static/img`. When we commit, our images will show in the CMS editor. 
